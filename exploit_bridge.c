/**
 * Exploit Security.
 *
 * [Exploit Bridge - UART and SPI]
 *
 */

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "hardware/clocks.h"
#include "pico/multicore.h"
#include "pico/stdlib.h"
#include "pico/binary_info.h"
#include "/opt/pico/pico-sdk/src/rp2040/hardware_structs/include/hardware/structs/uart.h"
#include "/opt/pico/pico-sdk/src/rp2_common/hardware_irq/include/hardware/irq.h"
#include "/opt/pico/pico-sdk/src/rp2040/hardware_regs/include/hardware/regs/pio.h"
#include "/opt/pico/pico-examples/build/pio/uart_rx/uart_rx.pio.h"
#include "/opt/pico/pico-sdk/lib/tinyusb/src/class/cdc/cdc_device.h"
#include "/opt/pico/pico-sdk/src/rp2_common/hardware_spi/include/hardware/spi.h"

/// Define the default UART1 state
#define UART_ID uart1
#define BAUD_RATE 115200
#define DATA_BITS 8
#define STOP_BITS 1
#define PARITY UART_PARITY_NONE

// We are using pins 4 and 5, but see the GPIO function select table in the
// datasheet for information on which other pins can be used.
#define UART_TX_PIN 4
#define UART_RX_PIN 5
#define PIO_RX_PIN 5

//Define the defaul SPI state
#define MISO 16
#define CS 17
#define SCLK 18
#define MOSI 19
#define SPI_PORT spi0

//static int chars_rxed = 0;

#define BUF_LEN 20

void printbuf(uint8_t buf[], size_t len) {
    int i;
    for (i = 0; i < len; ++i) {
        if (i % 16 == 15)
            printf("%02x\n", buf[i]);
        else
            printf("%02x ", buf[i]);
    }

    // append trailing newline if there isn't one
    if (i % 16) {
        putchar('\n');
    }
}

void curiosityBanner () {
    printf ("\n  ┌─┐┬ ┬┬─┐┬┌─┐┌─┐┬┌┬┐┬ ┬  ┌┬┐┬─┐┬┬  ┬┌─┐┌─┐  ┌─┐┬ ┬┬─┐  ┬  ┬┌─┐┬─┐┬ ┬  ┌─┐┌─┐┌┐ ┬─┐┬┌─┐\n");
    printf ("  │  │ │├┬┘││ │└─┐│ │ └┬┘   ││├┬┘│└┐┌┘├┤ └─┐  │ ││ │├┬┘  └┐┌┘├┤ ├┬┘└┬┘  ├┤ ├─┤├┴┐├┬┘││\n");
    printf ("  └─┘└─┘┴└─┴└─┘└─┘┴ ┴  ┴   ─┴┘┴└─┴ └┘ └─┘└─┘  └─┘└─┘┴└─   └┘ └─┘┴└─ ┴   └  ┴ ┴└─┘┴└─┴└─┘\n");
    sleep_ms(1000);
    _Exit(10);
}

void clearscreen() {
    //printf("\033c");
    printf("\x1b[2J");
    printf("╔═╗─┐ ┬┌─┐┬  ┌─┐┬┌┬┐  ╔╗ ┬─┐┬┌┬┐┌─┐┌─┐\n");
    printf("║╣ ┌┴┬┘├─┘│  │ ││ │   ╠╩╗├┬┘│ │││ ┬├┤ \n");
    printf("╚═╝┴ └─┴  ┴─┘└─┘┴ ┴   ╚═╝┴└─┴─┴┘└─┘└─┘\n");
    printf("[by Exploit Security]\n");
}

void spiBanner() {
    printf ("\n     ╔═╗┌─┐┬      \n");
    printf ("+────╚═╗├─┘│──────+\n");
    printf ("|    ╚═╝┴  ┴      |\n");
    printf ("|    1. Bridge    |\n");
    printf ("|    2. back      |\n");
    printf ("+─────────────────+\n");
}

int spi() {
    int choice = 0;
    char quit;
    uint8_t in_buf [BUF_LEN];
    while (choice != 2) {
       clearscreen();
       spiBanner(choice);
       printf("[Option]: ");
       choice = getchar();
       if (choice == '1') {
          for (u_int8_t i = 0; i < BUF_LEN; ++i) {
             in_buf [i] = 0;
          }
          while (quit != 'q')
          {
              gpio_put (CS, 0); // Enables communcation to the device
              printf("\n[Setting up bridge]");
              sleep_ms(1000);
              printf (" . ");
              sleep_ms(1000);
              printf (". ");
              sleep_ms(1000);
              printf (". ");
              sleep_ms(1000);
              printf (". ");
              printf("\n[Bridge Setup Complete]");
              //Here we setup SPI
              while (1) {
                 if (spi_is_readable (spi0)) {
                   printf ("\n[Reading data from SPI]\n");
                    // Write the output buffer to MOSI, and at the same time read from MISO.
                   spi_write_read_blocking (spi0, 0, in_buf, BUF_LEN);
                   printbuf (in_buf, BUF_LEN);
//                   printf ("Data received: %d\n", in_buf [0]);
                   //printf("Data received: %d\n", in_buf);
                   sleep_ms(1000);
                 } else {
                    printf ("\n**Read Failed!**");
                    printf ("\n[Press any key to continue]");
                    getchar();
                    return 0;
                 }
              }
              printf ("[Press 'q' to quit]: ");
              quit = getchar();
              gpio_put (CS, 1);
              printf("\n[Re-setting bridge]\n");
              sleep_ms(1000);
              printf (" . ");
              sleep_ms(1000);
              printf (". ");
              sleep_ms(1000);
              printf (". ");
              sleep_ms(1000);
              printf (". ");
              printf("\n[Bridge reset Complete]\n");
              printf ("[Press any key to continue]: ");
              getchar();
           }
        } else if (choice == '2') {
           return 0;
        } else {
           printf("**Invalid Choice**\n");
           sleep_ms(2000);
       }
   }
   return 0;
}

void uartScanBanner() {
    printf ("\n    ╔╗ ┌─┐┬ ┬┌┬┐  ╔═╗┌─┐┌─┐┌┐┌    \n");
    printf ("+───╠╩╗├─┤│ │ ││  ╚═╗│  ├─┤│││───+\n");
    printf ("|   ╚═╝┴ ┴└─┘─┴┘  ╚═╝└─┘┴ ┴┘└┘   |\n");
    printf ("+────────────────────────────────+\n");
    printf ("\n");
}

int uartScan () {
    int baudRate[9] = {2400,9600,19200,28800,38400,57600,76800,115200};
    clearscreen();
    uartScanBanner();
    char choice;
    int alphaCount = 0;
    PIO pio = pio0;
    uint sm = 0;
    uint offset = pio_add_program(pio, &uart_rx_program);
    while (uart_is_readable_within_us(UART_ID, 5000) || choice != 'q')
    {
       clearscreen();
       uartScanBanner();
//       uint f_clk_peri = frequency_count_khz(CLOCKS_FC0_SRC_VALUE_CLK_PERI);
//       printf("clk_peri = %dkHz\n", f_clk_peri);
//       printf("Any key...");
//       getchar();
       printf("\n[Scanning]");
       for (int i = 0; i < 8; i++)
       {
//          printf("\n[Scanning at baud rate %d bps]", baudRate[i]);
          uart_rx_program_init(pio, sm, offset, PIO_RX_PIN, baudRate[i]);
          sleep_ms(2000);
          for (int x = 0; x < 8; x++)
          {
             char c = uart_rx_program_getc(pio, sm);
             if (c != '\0' || c != '\n' || c != '\r' || c != '\t' || c != ' ' || c != '\v' || c != '\f')
             {
                if (isalpha(c))
                {
                   alphaCount++;
                } else {
                   continue;
                }
             } else {
                continue;
             }
          }
          if (alphaCount > 5)
          {
             printf("\n[Baud Rate Detected at %d bps]", baudRate[i]);
             alphaCount = 0; //Reinitialised
             continue;
          } else {
             //printf("\n**Baud Not Detected**");
             alphaCount = 0; //Reinitialised
             continue;
          }
          printf ("\r\n");
       }
       printf ("\n[Press 'q' to exit]\n");
       choice = getchar();
       return 0;
    }
    return 0;
}

// RX interrupt handler
int on_uart_rx(int baud) {
    PIO pio = pio0;
    uint sm = 0;
    uint offset = pio_add_program(pio, &uart_rx_program);
    uart_rx_program_init(pio, sm, offset, PIO_RX_PIN, baud);
    printf("\n[Connecting at Baud Rate: %d]", baud);
    while (uart_is_readable(UART_ID)) {
       char c = uart_rx_program_getc(pio, sm);
       putchar(c);
    }
    printf("\n**Data Timeout**\n");
    sleep_ms (2000);
    return 0;
}

int passthroughMenu() {
   int choice = 0;
   while (choice != 9) {
   clearscreen();
   printf("\n    ╔╗ ┌─┐┬ ┬┌┬┐  ╦═╗┌─┐┌┬┐┌─┐\n");
   printf("+───╠╩╗├─┤│ │ ││  ╠╦╝├─┤ │ ├┤ ──+\n");
   printf("|   ╚═╝┴ ┴└─┘─┴┘  ╩╚═┴ ┴ ┴ └─┘  |\n");
   printf("|   1. 2400                     |\n");
   printf("|   2. 9600                     |\n");
   printf("|   3. 19200                    |\n");
   printf("|   4. 28800                    |\n");
   printf("|   5. 38400                    |\n");
   printf("|   6. 57600                    |\n");
   printf("|   7. 76800                    |\n");
   printf("|   8. 115200                   |\n");
   printf("|   9. back                     |\n");
   printf("+───────────────────────────────+\n");
   printf("[Option]: ");
   choice = getchar();
   if (choice == '1') {
       int __unused actual = uart_set_baudrate(UART_ID, 2400);
       on_uart_rx(actual);
   } else if (choice == '2') {
       int __unused actual = uart_set_baudrate(UART_ID, 9600);
       on_uart_rx(actual);
   } else if (choice == '3') {
       int __unused actual = uart_set_baudrate(UART_ID, 19200);
       on_uart_rx(actual);
   } else if (choice == '4') {
       int __unused actual = uart_set_baudrate(UART_ID, 28800);
       on_uart_rx(actual);
   } else if (choice == '5') {
       int __unused actual = uart_set_baudrate(UART_ID, 38400);
       on_uart_rx(actual);
   } else if (choice == '6') {
       int __unused actual = uart_set_baudrate(UART_ID, 57600);
       on_uart_rx(actual);
   } else if (choice == '7') {
       int __unused actual = uart_set_baudrate(UART_ID, 76800);
       on_uart_rx(actual);
   } else if (choice == '8') {
       int __unused actual = uart_set_baudrate(UART_ID, 115200);
       on_uart_rx(actual);
   } else if (choice == '9') {
       return 0;
   } else {
       printf("**Invalid Choice**\n");
       sleep_ms(2000);
   }
}
return 0;
}

int uartMenu() {
   int choice = 0;
   while (choice != 3) {
      clearscreen();
      printf("\n    ╔╦╗┌─┐┌┐┌┬ ┬\n");
      printf("+───║║║├┤ ││││ │────+\n");
      printf("|   ╩ ╩└─┘┘└┘└─┘    |\n");
      printf("|   1. Scan         |\n");
      printf("|   2. Passthrough  |\n");
      printf("|   3. back         |\n");
      printf("+───────────────────+\n");
      printf("[Option]: ");
      choice = getchar();
      if (choice == '1') {
         clearscreen();
         uartScan();
      } else if (choice == '2') {
         clearscreen();
         passthroughMenu();
      } else if (choice == '3') {
         return 0;
      } else {
         printf("**Invalid Choice**\n");
         sleep_ms(2000);
     }
 }
 return 0;
}

int firstMenu() {
    int choice = 0;
    printf("\n    ╔╦╗┌─┐┌┐┌┬ ┬\n");
    printf("+───║║║├┤ ││││ │───+\n");
    printf("|   ╩ ╩└─┘┘└┘└─┘   |\n");
    printf("|   1. UART        |\n");
    printf("|   2. SPI         |\n");
    printf("|   3. exit        |\n");
    printf("+──────────────────+\n");
    printf("[Option]: ");
    choice = getchar();
    if (choice == '1') {
        clearscreen();
        uartMenu();
    } else if (choice == '2') {
        clearscreen();
        spiBanner();
        spi();
    } else if (choice == '3') {
        clearscreen();
        curiosityBanner();
    } else {
        printf("**Invalid Choice**\n");
        sleep_ms(2000);
    }
    return 0;
}

int main() {
    stdio_init_all();
    stdio_usb_init();
    stdio_uart_init();
    stdio_flush();
    // Set up our UART with a initialised BAUD rate.
    uart_init(UART_ID, 57600);
    PIO pio = pio0;
    uint sm = 0;
    uint offset = pio_add_program(pio, &uart_rx_program);
    uart_rx_program_init(pio, sm, offset, PIO_RX_PIN, BAUD_RATE);

    // Set the TX and RX pins by using the function select on the GPIO
    // Set datasheet for more information on function select
    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);
    // Set UART flow control CTS/RTS, we don't want these, so turn them off
    uart_set_hw_flow(UART_ID, false, false);

    // Set our data format
    uart_set_format(UART_ID, DATA_BITS, STOP_BITS, PARITY);

    // Turn off FIFO's - we want to do this character by character
    uart_set_fifo_enabled(UART_ID, false);

    // Set up a RX interrupt
    // We need to set up the handler first
    // Select correct interrupt for the UART we are using
    //int UART_IRQ = UART_ID == uart0 ? UART0_IRQ : UART1_IRQ;

    // And set up and enable the interrupt handlers
    //irq_set_exclusive_handler(UART_IRQ, on_uart_rx);
    //irq_set_enabled(UART_IRQ, true);

    // Now enable the UART to send interrupts - RX only
    //uart_set_irq_enables(UART_ID, true, false);

    // Initialise SPI
    spi_init(SPI_PORT, 1000 * 1000); // Initialise SPI at 1MHz
    gpio_set_function(MISO, GPIO_FUNC_SPI);
    gpio_set_function(MOSI, GPIO_FUNC_SPI);
    gpio_set_function(SCLK, GPIO_FUNC_SPI);
    gpio_init(CS);
    gpio_set_dir(CS, GPIO_OUT);
//    gpio_put(CS, 1); // Setup exploit bridge as SPI non communicating
//    spi_set_slave(spi0, true);
//    bi_decl(bi_4pins_with_func(MISO, MOSI, SCLK, CS, GPIO_FUNC_SPI));

    while (1)
    {
       clearscreen();
       firstMenu();
    }
//    gpio_put(CS,1); // Reset exploit bridge SPI bridge to non-master
    return 0;
}
