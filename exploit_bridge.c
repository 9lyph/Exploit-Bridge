/**
 * Exploit Security.
 *
 * [Exploit Bridge - UART and SPI]
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <signal.h>
#include "hardware/clocks.h"
#include "pico/multicore.h"
#include "pico/stdlib.h"
#include "pico/binary_info.h"
#include "/opt/pico/pico-sdk/src/rp2040/hardware_structs/include/hardware/structs/uart.h"
#include "/opt/pico/pico-sdk/src/rp2_common/hardware_irq/include/hardware/irq.h"
#include "/opt/pico/pico-sdk/src/rp2040/hardware_regs/include/hardware/regs/pio.h"
#include "/opt/pico/pico-examples/build/pio/uart_rx/uart_rx.pio.h"
#include "/opt/pico/pico-sdk/lib/tinyusb/src/class/cdc/cdc_device.h"
#include "/opt/pico/pico-sdk/src/rp2_common/hardware_spi/include/hardware/spi.h"

/// Define the default UART1 state
#define UART_ID uart1
#define BAUD_RATE 115200
#define DATA_BITS 8
#define STOP_BITS 1
#define PARITY UART_PARITY_NONE

// We are using pins 4 and 5, but see the GPIO function select table in the
// datasheet for information on which other pins can be used.
#define UART_TX_PIN 4
#define UART_RX_PIN 5
#define PIO_RX_PIN 5

//Define the defaul SPI state
#define MISO 16
#define CS 17
#define SCLK 18
#define MOSI 19
#define SPI_PORT spi0

//static int chars_rxed = 0;

#define BUF_LEN 20
#define FLASH_PAGE_SIZE        256
#define FLASH_SECTOR_SIZE      4096

#define FLASH_CMD_PAGE_PROGRAM 0x02
#define FLASH_CMD_READ         0x03
#define FLASH_CMD_STATUS       0x05
#define FLASH_CMD_WRITE_EN     0x06
#define FLASH_CMD_SECTOR_ERASE 0x20

#define FLASH_STATUS_BUSY_MASK 0x01

/*static inline void cs_select(CS) {
    asm volatile("nop \n nop \n nop"); // FIXME
    gpio_put(CS, 0);
    asm volatile("nop \n nop \n nop"); // FIXME
}*/

/*static inline void cs_deselect(CS) {
    asm volatile("nop \n nop \n nop"); // FIXME
    gpio_put(CS, 1);
    asm volatile("nop \n nop \n nop"); // FIXME
}*/


void __not_in_flash_func(flash_read)(spi_inst_t *spi, uint cs_pin, uint32_t addr, uint8_t *buf, size_t len) {
    gpio_put(CS, 0);
    uint8_t cmdbuf[4] = {
            FLASH_CMD_READ,
            addr >> 16,
            addr >> 8,
            addr
    };
    spi_write_blocking(SPI_PORT, cmdbuf, 4);
    spi_read_blocking(SPI_PORT, 0, buf, len);
    gpio_put(CS, 1);
}

void __not_in_flash_func(flash_write_enable)(spi_inst_t *spi, uint cs_pin) {
    gpio_put(CS, 0);
    uint8_t cmd = FLASH_CMD_WRITE_EN;
    spi_write_blocking(SPI_PORT, &cmd, 1);
    gpio_put(CS, 1);
}

void __not_in_flash_func(flash_wait_done)(spi_inst_t *spi, uint cs_pin) {
    uint8_t status;
    do {
        gpio_put(CS, 0);
        uint8_t buf[2] = {FLASH_CMD_STATUS, 0};
        spi_write_read_blocking(SPI_PORT, buf, buf, 2);
        gpio_put(CS, 1);
        status = buf[1];
    } while (status & FLASH_STATUS_BUSY_MASK);
}

void __not_in_flash_func(flash_sector_erase)(spi_inst_t *spi, uint cs_pin, uint32_t addr) {
    uint8_t cmdbuf[4] = {
            FLASH_CMD_SECTOR_ERASE,
            addr >> 16,
            addr >> 8,
            addr
    };
    flash_write_enable(SPI_PORT, CS);
    gpio_put(CS, 0);
    spi_write_blocking(SPI_PORT, cmdbuf, 4);
    gpio_put(CS, 1);
    flash_wait_done(SPI_PORT, CS);
}

void __not_in_flash_func(flash_page_program)(spi_inst_t *spi, uint cs_pin, uint32_t addr, uint8_t data[]) {
    uint8_t cmdbuf[4] = {
            FLASH_CMD_PAGE_PROGRAM,
            addr >> 16,
            addr >> 8,
            addr
    };
    flash_write_enable(SPI_PORT, CS);
    gpio_put(CS, 0);
    spi_write_blocking(SPI_PORT, cmdbuf, 4);
    spi_write_blocking(SPI_PORT, data, FLASH_PAGE_SIZE);
    gpio_put(CS, 1);
    flash_wait_done(SPI_PORT, CS);
}

void printbuf(uint8_t buf[FLASH_PAGE_SIZE]) {
    for (int i = 0; i < FLASH_PAGE_SIZE; ++i) {
        if (i % 16 == 15)
            printf("%02x\n", buf[i]);
        else
            printf("%02x ", buf[i]);
    }
}

int keepRunning = 1;

void intHandler(int signum) {
    (void)signum;
    keepRunning = 0;
}

void curiosityBanner () {
    printf ("\n  ┌─┐┬ ┬┬─┐┬┌─┐┌─┐┬┌┬┐┬ ┬  ┌┬┐┬─┐┬┬  ┬┌─┐┌─┐  ┌─┐┬ ┬┬─┐  ┬  ┬┌─┐┬─┐┬ ┬  ┌─┐┌─┐┌┐ ┬─┐┬┌─┐\n");
    printf ("  │  │ │├┬┘││ │└─┐│ │ └┬┘   ││├┬┘│└┐┌┘├┤ └─┐  │ ││ │├┬┘  └┐┌┘├┤ ├┬┘└┬┘  ├┤ ├─┤├┴┐├┬┘││\n");
    printf ("  └─┘└─┘┴└─┴└─┘└─┘┴ ┴  ┴   ─┴┘┴└─┴ └┘ └─┘└─┘  └─┘└─┘┴└─   └┘ └─┘┴└─ ┴   └  ┴ ┴└─┘┴└─┴└─┘\n");
    sleep_ms(1000);
    _Exit(10);
}

void clearscreen() {
    //printf("\033c");
    printf("\x1b[2J");
    printf("╔═╗─┐ ┬┌─┐┬  ┌─┐┬┌┬┐  ╔╗ ┬─┐┬┌┬┐┌─┐┌─┐\n");
    printf("║╣ ┌┴┬┘├─┘│  │ ││ │   ╠╩╗├┬┘│ │││ ┬├┤ \n");
    printf("╚═╝┴ └─┴  ┴─┘└─┘┴ ┴   ╚═╝┴└─┴─┴┘└─┘└─┘\n");
    printf("[by Exploit Security]\n");
}

int spi_areyousure() {
   char choice;
   bool ok = false;
   printf("\n[Ensure SPI is correctly connected to peripheral]");
   printf("\n[Would you like to continue (Y/N)]: ");
   choice = getchar();
   if (choice == 'y') {
      ok = true;
      return (ok);
   } else if (choice == 'n') {
      ok = false;
      return (ok);
   }
   return 0;
}

void spiBanner() {
    printf ("\n        ╔═╗┌─┐┬      \n");
    printf ("+───────╚═╗├─┘│────────+\n");
    printf ("|       ╚═╝┴  ┴        |\n");
    printf ("|    1. Read           |\n");
    printf ("|    [ESC]             |\n");
    printf ("+──────────────────────+\n");
}

int spi() {
    int choice = 0;
    uint8_t in_buf [BUF_LEN];
    bool ok = false;
    uint8_t page_buf[FLASH_PAGE_SIZE];
    const uint32_t target_addr = 0;

    printf("[Option]: ");
    choice = getchar();
    if (choice == '1')
    {
        ok =  spi_areyousure();
        if (ok)
        {
           printf("\n[Setting up bridge]");
           sleep_ms(1000);
           printf (".");
           sleep_ms(1000);
           printf (".");
           sleep_ms(1000);
           printf (".");
           sleep_ms(1000);
           printf (".");
           printf("\n[Bridge Setup Complete]");

           while (spi_is_readable(SPI_PORT) || spi_is_writable(SPI_PORT))
           {
              printf ("\n[Reading data from SPI]\n");
              flash_read(SPI_PORT, CS, target_addr, page_buf, FLASH_PAGE_SIZE);
              printbuf(page_buf);
              for (int i = 0; i < FLASH_PAGE_SIZE; ++i)
                 page_buf[i] = i;
                 flash_page_program(SPI_PORT, CS, target_addr, page_buf);
                 flash_read(SPI_PORT, CS, target_addr, page_buf, FLASH_PAGE_SIZE);
                 printbuf(page_buf);
//              for (int i = 0; i < BUF_LEN; i++)
//              {
//                 spi_read_blocking (SPI_PORT, 0, &in_buf[i], BUF_LEN);
//                 printf("SPI master says: read page %d from the MISO line:\n", i);
//                 printf("\n%02x ", &in_buf[i]);
//                 sleep_ms(1000);
//              }
              keepRunning = 0;
              printf("Press any key to continue");
              getchar();
              break;
           }
//           gpio_put (CS, 1);
           printf("\n[Resetting bridge]");
           sleep_ms(1000);
           printf (".");
           sleep_ms(1000);
           printf (".");
           sleep_ms(1000);
           printf (".");
           sleep_ms(1000);
           printf (".");
           printf("\n[Bridge reset complete]\n");
           sleep_ms(1000);
        } else {
           return 0;
        }
    } else {
       return 0;
    }
 return 0;
}

void uartScanBanner() {
    printf ("\n    ╔╗ ┌─┐┬ ┬┌┬┐  ╔═╗┌─┐┌─┐┌┐┌    \n");
    printf ("+───╠╩╗├─┤│ │ ││  ╚═╗│  ├─┤│││───+\n");
    printf ("|   ╚═╝┴ ┴└─┘─┴┘  ╚═╝└─┘┴ ┴┘└┘   |\n");
    printf ("+────────────────────────────────+\n");
}

int uartScan () {
    while (keepRunning) 
    {
       int baudRate[9] = {2400,9600,19200,28800,38400,57600,76800,115200};
       clearscreen();
       uartScanBanner();
       char choice;
       int alphaCount = 0;
       PIO pio = pio0;
       uint sm = 0;
       uint offset = pio_add_program(pio, &uart_rx_program);
       printf("\n[Ensure UART is correctly connected to peripheral]");
       printf("\n[Would you like to continue (Y/N)]: ");
       choice = getchar();
       if (choice == 'y') 
       {
          while (keepRunning == 1 || choice != 'q')
          {
             clearscreen();
             uartScanBanner();
             printf("\n[Scanning]");
             if (uart_is_writable(UART_ID))
             {
                for (int i = 0; i < 8; i++)
                {
                   uart_rx_program_init(pio, sm, offset, PIO_RX_PIN, baudRate[i]);
                   sleep_ms(2000);
                   for (int x = 0; x < 8; x++)
                   {
                      char c = uart_rx_program_getc(pio, sm);
                      if (c != '\0' || c != '\n' || c != '\r' || c != '\t' || c != ' ' || c != '\v' || c != '\f')
                      {
                         if (isalpha(c))
                         {
                            alphaCount++;
                         } else {
                            continue;
                         }
                      } else {
                         continue;
                      }
                   }
                   if (alphaCount > 5)
                   {
                      printf("\n[Baud Rate Detected at %d bps]", baudRate[i]);
                      alphaCount = 0; //Reinitialised
                      continue;
                   } else {
                      alphaCount = 0; //Reinitialised
                      continue;
                   }
                   printf ("\r\n");
                }
                printf ("\n[Press 'q' to exit]\n");
                choice = getchar();
                return 0;
             } else {
                return 0;
             }
          }
       } else if (choice == 'n') {
          return 0;
       }
       return 0;
    }
    return 0;
}

// RX interrupt handler
int on_uart_rx(int baud) {
    PIO pio = pio0;
    uint sm = 0;
    uint offset = pio_add_program(pio, &uart_rx_program);
    uart_rx_program_init(pio, sm, offset, PIO_RX_PIN, baud);
    printf("\n[Connecting at Baud Rate: %d]", baud);
    while (uart_is_readable_within_us(UART_ID, 2000))
    {
       while (keepRunning)
       {
          char c = uart_rx_program_getc(pio, sm);
          putchar(c);
       }
    }
    printf("\n**Data Timeout**\n");
    sleep_ms (2000);
    return 0;
}

int areyousure() {
   char choice;
   bool ok = false;
   printf("\n[Ensure UART is correctly connected to peripheral]");
   printf("\n[Would you like to continue (Y/N)]: ");
   choice = getchar();
   if (choice == 'y') {
      ok = true;
      return (ok);
   } else if (choice == 'n') {
      ok = false;
      return (ok);
   }
   return 0;
}

int passthroughMenu() {
   int choice = 0;
   bool ok = false;
   while (keepRunning) {
   clearscreen();
   printf("\n    ╔╗ ┌─┐┬ ┬┌┬┐  ╦═╗┌─┐┌┬┐┌─┐\n");
   printf("+───╠╩╗├─┤│ │ ││  ╠╦╝├─┤ │ ├┤ ──+\n");
   printf("|   ╚═╝┴ ┴└─┘─┴┘  ╩╚═┴ ┴ ┴ └─┘  |\n");
   printf("|   1. 2400                     |\n");
   printf("|   2. 9600                     |\n");
   printf("|   3. 19200                    |\n");
   printf("|   4. 28800                    |\n");
   printf("|   5. 38400                    |\n");
   printf("|   6. 57600                    |\n");
   printf("|   7. 76800                    |\n");
   printf("|   8. 115200                   |\n");
   printf("|   [ESC]                       |\n");
   printf("+───────────────────────────────+\n");
   printf("[Option]: ");
   choice = getchar();
   if (choice == '1') {
       ok = areyousure();
       if (ok) {
          int __unused actual = uart_set_baudrate(UART_ID, 2400);
          on_uart_rx(actual);
       } else {
          return 0;
       }
   } else if (choice == '2') {
       ok = areyousure();
       if (ok) {
          int __unused actual = uart_set_baudrate(UART_ID, 9600);
          on_uart_rx(actual);
       } else {
          return 0;
       }
   } else if (choice == '3') {
       ok = areyousure();
       if (ok) {
          int __unused actual = uart_set_baudrate(UART_ID, 19200);
          on_uart_rx(actual);
       } else {
          return 0;
       }
   } else if (choice == '4') {
       ok = areyousure();
       if (ok) {
          int __unused actual = uart_set_baudrate(UART_ID, 28800);
         on_uart_rx(actual);
      } else {
         return 0;
      }
   } else if (choice == '5') {
       ok = areyousure();
       if (ok) {
          int __unused actual = uart_set_baudrate(UART_ID, 38400);
          on_uart_rx(actual);
       } else {
          return 0;
       }
   } else if (choice == '6') {
       ok = areyousure();
       if (ok) {
          int __unused actual = uart_set_baudrate(UART_ID, 57600);
          on_uart_rx(actual);
       } else {
          return 0;
       }
   } else if (choice == '7') {
       ok = areyousure();
       if (ok) {
          int __unused actual = uart_set_baudrate(UART_ID, 76800);
          on_uart_rx(actual);
       } else {
          return 0;
       }
   } else if (choice == '8') {
       ok = areyousure();
       if (ok) {
          int __unused actual = uart_set_baudrate(UART_ID, 115200);
          on_uart_rx(actual);
       } else {
          return 0;
       }
   } else {
       return 0;
   }
}
return 0;
}

int uartMenu() {
   int choice = 0;
   while (keepRunning) {
      clearscreen();
      printf("\n      ╔╦╗┌─┐┌┐┌┬ ┬\n");
      printf("+─────║║║├┤ ││││ │────+\n");
      printf("|     ╩ ╩└─┘┘└┘└─┘    |\n");
      printf("|    1. Scan          |\n");
      printf("|    2. Passthrough   |\n");
      printf("|    [ESC]            |\n");
      printf("+─────────────────────+\n");
      printf("[Option]: ");
      choice = getchar();
      if (choice == '1') {
         clearscreen();
         uartScan();
      } else if (choice == '2') {
         clearscreen();
         passthroughMenu();
      } else {
         return 0;
     }
 }
 return 0;
}

int firstMenu() {
    int choice = 0;
    printf("\n    ╔╦╗┌─┐┌┐┌┬ ┬\n");
    printf("+───║║║├┤ ││││ │───+\n");
    printf("|   ╩ ╩└─┘┘└┘└─┘   |\n");
    printf("|   1. UART        |\n");
    printf("|   2. SPI         |\n");
    printf("|   3. Exit        |\n");
    printf("+──────────────────+\n");
    printf("[Option]: ");
    choice = getchar();
    if (choice == '1') {
        clearscreen();
        uartMenu();
    } else if (choice == '2') {
        clearscreen();
        spiBanner();
        spi();
    } else if (choice == '3') {
        clearscreen();
        curiosityBanner();
    } else {
        return 0;
    }
    return 0;
}

int main() {
    stdio_init_all();
    stdio_usb_init();
    stdio_uart_init();
    stdio_flush();
    // Set up our UART with a initialised BAUD rate.
    uart_init(UART_ID, 57600);
    PIO pio = pio0;
    uint sm = 0;
    uint offset = pio_add_program(pio, &uart_rx_program);
    uart_rx_program_init(pio, sm, offset, PIO_RX_PIN, BAUD_RATE);

    // Set the TX and RX pins by using the function select on the GPIO
    // Set datasheet for more information on function select
    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);
    // Set UART flow control CTS/RTS, we don't want these, so turn them off
    uart_set_hw_flow(UART_ID, false, false);

    // Set our data format
    uart_set_format(UART_ID, DATA_BITS, STOP_BITS, PARITY);

    // Turn off FIFO's - we want to do this character by character
    uart_set_fifo_enabled(UART_ID, false);

    // Set up a RX interrupt
    // We need to set up the handler first
    // Select correct interrupt for the UART we are using
    //int UART_IRQ = UART_ID == uart0 ? UART0_IRQ : UART1_IRQ;

    // And set up and enable the interrupt handlers
    //irq_set_exclusive_handler(UART_IRQ, on_uart_rx);
    //irq_set_enabled(UART_IRQ, true);

    // Now enable the UART to send interrupts - RX only
    //uart_set_irq_enables(UART_ID, true, false);

    // Initialise SPI
    spi_init(SPI_PORT, 1000 * 1000); // Initialise SPI at 1MHz
//    spi_set_slave(SPI_PORT, true);
    gpio_set_function(MISO, GPIO_FUNC_SPI);
    gpio_set_function(MOSI, GPIO_FUNC_SPI);
    gpio_set_function(SCLK, GPIO_FUNC_SPI);
    gpio_set_function(CS, GPIO_FUNC_SPI);
    bi_decl(bi_3pins_with_func(MISO, MOSI, SCLK, GPIO_FUNC_SPI));
    gpio_init(CS);
    gpio_put(CS, 1);
    gpio_set_dir(CS, GPIO_OUT);

    while (1)
    {
       clearscreen();
       firstMenu();
    }
//    gpio_put(CS,1); // Reset exploit bridge SPI bridge to non-master
    return 0;
}
